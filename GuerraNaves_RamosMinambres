//Javier Ramos - Alejandro Minambres
//Los * es que se dispara y se acierta
//Los espacios es que se dispara y falla
//Las b siempre están seguidas de un número --> Botiquin se toma una vida y deja una menos de las que tiene
//Cualquier otro caracter es invalido

//Recibe por parámetros fichero de entrada, fichero de salida, tamaño del buffer, número de naves que compiten
//Tienes que comprobar que los parámetros son correctos y que son 4 (5 cosas)
//Mirar si el fichero existe...
//Tenemos que validar completamente la entrada

//El primer hilo es disparador que solo es 1 hilo
//Este hilo lee los caracteres del fichero
//Cuenta los invalidos
//Los válidos los mete en un buffer circular del tamaño que se indica

//Cada hilo es una nave y lo que lee es lo que recibe
//En los botiquines también se modifica el buffer --> El botiquin solo se borra cuando tiene 0 vidas

//Después escriben los resultados en la lista enlazada por turnos

//El hilo juez comprueba escribe los resultados que dicen las naves y decide que hilo gana

//Como el disparador imprime en el fichero los resultados de la lectura y el juez también --> Lo usas para comporbar

//Entrega 0 es el 2 diciembre --> Disparador y una única nave
//Con dos semáforos se puede
//Podemos hacer una versión con botiquines
//Que por ahora lo esciba en un vector

//Fase 2 el juez y varias naves con el vector

//Fase 3 convertir el vector en la lista enlazada


//El main espera a que se termine destruye todos los semáforos y todos los free y termina


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>

// Variables Compartidas
char* Buffer;
int posicion_escritura;
int posicion_lectura;

// Semaforos
sem_t espacio_buffer;
sem_t mutex_disparador_posicion;
sem_t haydatos;


struct Datos
{
    char* fichero_entrada;
    char* fichero_salida;    
    int buffersize;
    int numnaves; 
};



// Hilo Disparador 
void* disparador(void* arg)
{
    struct Datos * datos_disparador;
    datos_disparador = (struct Datos*)arg;
    FILE *fichero_entrada = fopen(datos_disparador->fichero_entrada, "r");

    char caracter;
    bool caracter_correcto;
    int correctos = 0;
    int incorrectos = 0;
    int leidos = 0;
    while ((caracter = fgetc(fichero_entrada)) != EOF) 
    {
        caracter_correcto = false;
        leidos ++;

        if(caracter == '*')
        {
            caracter_correcto = true;
        }
        else if (caracter == ' ')
        {            
            caracter_correcto = true;
        }
        else if (caracter == 'b')
        {
            caracter = fgetc(fichero_entrada);  // El número de vidas
            if ((caracter == '1') || (caracter == '2') || (caracter == '3'))
            {
                caracter_correcto = true;
            }
        }

        if (caracter_correcto)
        {
            correctos ++;

            sem_wait(&mutex_disparador_posicion);
            int pos = posicion_escritura;
            posicion_escritura = (posicion_escritura + 1) % datos_disparador->buffersize;
            sem_post(&mutex_disparador_posicion);

            sem_wait(&espacio_buffer);
            Buffer[pos] = caracter;
            sem_post(&espacio_buffer);
            

            sem_post(&haydatos);
        } 
        else
        {
            incorrectos ++;
        }             
    }
    fclose(fichero_entrada);

    // Se escriben los resultados
    FILE *fichero_salida = fopen(datos_disparador->fichero_salida, "w");
    fprintf(fichero_salida, "El disparador ha procesado: %d tokens válidos y %d tokens inválidos, total: %d", correctos, incorrectos, leidos);
    fclose(fichero_salida);

    return 0;
}


// Hilo Nave
void* Naves(void* arg)
{
    return 0;
}




int main(int argc, char* argv[])
{
    // Variables
    char* fichero_entrada;
    char* fichero_salida;
    int buffersize; 
    int numnaves;
    FILE *ficheros;

    if(argc != 5)
    {
        //Se comprueba que el numero de parametros sea correcto
        printf("El numero de parametros no es correcto\n");
        exit(0);
    }
    else
    {
        // Se comprueba que el fichero de entrada existe
        fichero_entrada = argv[1];
        
        if (ficheros = fopen(fichero_entrada, "r")) 
        {
            // El fichero existe
            fclose(ficheros);
        }
        else
        {
            printf("No se ha podido abrir el archivo (de entrada)\n");
            exit(-1);
        } 

        // Se comprueba que el fichero de salida existe
        fichero_salida = argv[2];
        if (ficheros = fopen(fichero_salida, "r")) 
        {
            // El fichero existe
            fclose(ficheros);
        }
        else
        {
            printf("No se ha podido abrir el archivo (de salida)\n");
            exit(-1);
        }         

        // Se comprueba que el tamano del buffer es correcto
        buffersize = atoi(argv[3]);
        if(buffersize <= 0)
        {
            printf("El valor introducido para el tamano del buffer es incorrecto\n");
            exit(-1);
        }

        // Se comprueba que el numero de naves es correcto
        numnaves = atoi(argv[4]);
        if(numnaves <= 0)
        {
            printf("El valor introducido para el numero de naves es incorrecto\n");
            exit(-1);
        }
    }

    // Se crea un tipo de datos con toda la informacion necesaria
    struct Datos datos;
    datos.fichero_entrada = fichero_entrada;
    datos.fichero_salida = fichero_salida;
    datos.buffersize = buffersize;
    datos.numnaves = numnaves;

    // Se inicializan las variables
    posicion_escritura = 0;
    posicion_lectura = 0;
    Buffer = (char*)malloc(buffersize*sizeof(char));

    // Se inicializan los semaforos
    sem_init(&espacio_buffer, 0, buffersize);
    sem_init(&mutex_disparador_posicion, 0, 1);
    sem_init(&haydatos, 0, 0);
    
    // Se crea el hilo disparador
    pthread_t Disparador;
    pthread_create(&Disparador, NULL, disparador, (void*)&datos);    
    pthread_join(Disparador, NULL);


    //TODO resto del programa


    printf("%s", Buffer);
    sem_destroy(&espacio_buffer);
    sem_destroy(&mutex_disparador_posicion);
    sem_destroy(&haydatos);
    free(Buffer);
    
    return 0;
}
